/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.28                          *
*        Compiled Jan 30 2015, 16:41:06                              *
*        (c) 2015 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

#include "EJE_SWRB_TEST_SLAMDLG.h"

#include "EJE_SWRB_TEST_DLG_Conf.h"
#include "GUI.h"
#include "DIALOG.h"

#include "sweeprobot_testing.h"

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/

typedef void (*SLAMCbFunc_t)(void);

static SLAMCbFunc_t SLAMWMPaintCb;
static SLAMCbFunc_t SLAMRobotPaintCb;

#define SWRB_SLAM_WM_PAINT_CB_REG(f)        do{SLAMWMPaintCb=f;}while(0)
#define SWRB_SLAM_WM_PAINT_CB_DEREG()       do{SLAMWMPaintCb=NULL;}while(0)
#define SWRB_SLAM_ROBOT_PAINT_CB_REG(f)     do{SLAMRobotPaintCb=f;}while(0)
#define SWRB_SLAM_ROBOT_PAINT_CB_DEREG()    do{SLAMRobotPaintCb=NULL;}while(0)

#define SWRB_SLAM_MAP_X_START_POS           100
#define SWRB_SLAM_MAP_X_STOP_POS            600
#define SWRB_SLAM_MAP_X_AXIS_PIXEL_NUM      (SWRB_SLAM_MAP_X_STOP_POS-SWRB_SLAM_MAP_X_START_POS)
#define SWRB_SLAM_MAP_Y_START_POS           50
#define SWRB_SLAM_MAP_Y_STOP_POS            400
#define SWRB_SLAM_MAP_Y_AXIS_PIXEL_NUM      (SWRB_SLAM_MAP_Y_STOP_POS-SWRB_SLAM_MAP_Y_START_POS)

#define SWRB_SLAM_MAP_X_AXIS_GRID_SIZE      10
#define SWRB_SLAM_MAP_Y_AXIS_GRID_SIZE      10

#define SWRB_SLAM_MAP_X_AXIS_GRID_NUM       (SWRB_SLAM_MAP_X_AXIS_PIXEL_NUM/SWRB_SLAM_MAP_X_AXIS_GRID_SIZE)
#define SWRB_SLAM_MAP_Y_AXIS_GRID_NUM       (SWRB_SLAM_MAP_Y_AXIS_PIXEL_NUM/SWRB_SLAM_MAP_Y_AXIS_GRID_SIZE)

#define SWRB_SLAM_ROBOT_POS_OFFSET          SWRB_SLAM_MAP_X_AXIS_GRID_SIZE/2
#define SWRB_SLAM_ROBOT_MOVE_PIXEL_SPEED    10
#define SWRB_SLAM_ROBOT_NORTH_BOUND         (SWRB_SLAM_MAP_Y_START_POS+SWRB_SLAM_ROBOT_POS_OFFSET)
#define SWRB_SLAM_ROBOT_EAST_BOUND          (SWRB_SLAM_MAP_X_STOP_POS-SWRB_SLAM_ROBOT_POS_OFFSET)
#define SWRB_SLAM_ROBOT_SOUTH_BOUND         (SWRB_SLAM_MAP_Y_STOP_POS-SWRB_SLAM_ROBOT_POS_OFFSET)
#define SWRB_SLAM_ROBOT_WEST_BOUND          (SWRB_SLAM_MAP_X_START_POS+SWRB_SLAM_ROBOT_POS_OFFSET)

#define SWRB_SLAM_START_X_POS               345
#define SWRB_SLAM_START_Y_POS               235
#define SWRB_SLAM_START_ANGLE               0

#define DEG2RAD                             (3.1415926f / 180)

typedef struct{
    int GridStartXpos;
    int GridStartYpos;
    int GridStopXpos;
    int GridStopYpos;
    u8  flag;
}SWRB_SLAM_MAP_t;

enum SLAM_ROBOT_POS_EDGE_FLAG{
    
    SLAM_ROBOT_POS_EDGE_NONE,
    SLAM_ROBOT_POS_EDGE_HORIZON,
    SLAM_ROBOT_POS_EDGE_VERTICAL,
};

enum SLAM_ROBOT_POS_FLAG{
    
    SLAM_ROBOT_POS_NORTH,
    SLAM_ROBOT_POS_EAST,
    SLAM_ROBOT_POS_SOUTH,
    SLAM_ROBOT_POS_WEST,
    SLAM_ROBOT_POS_MIDDLE,
};

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

static enum SLAM_ROBOT_POS_EDGE_FLAG gRobotPosEdgeFlag = SLAM_ROBOT_POS_EDGE_NONE;
static enum SLAM_ROBOT_POS_FLAG gRobotPosFlag = SLAM_ROBOT_POS_MIDDLE;

static int slamXPos=SWRB_SLAM_START_X_POS, slamYPos=SWRB_SLAM_START_Y_POS;
static float slamAngle = SWRB_SLAM_START_ANGLE;

//static SWRB_SLAM_MAP_t gSLAMMap[SWRB_SLAM_MAP_X_AXIS_GRID_NUM][SWRB_SLAM_MAP_Y_AXIS_GRID_NUM] = { 0 };
//static SWRB_SLAM_MAP_t gSLAMMap[1][1];

static GUI_POINT pPolygonRobot[] = {
    {0,0},
    {0,0},
    {0,0},
    {0,0},
};
static short pPolygonRobotArray[4][4][2] = {
    {{-5,10}, {0,0}, {5,10}, {0,5}},        //North
    {{-10,-5}, {0,0}, {-10,5}, {-5,0}},     //East
    {{-5,-10}, {0,-5}, {5,-10}, {0,0}},     //South
    {{10,-5}, {0,0}, {10,5}, {5,0}}         //West
};

//static int gTraceNum = 0;
//static GUI_POINT gPolygonTrace[128];

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { WINDOW_CreateIndirect, "winSLAM", ID_SLAM_WINDOW_MAIN, 0, 0, 800, 480, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "SLAM Monitor", ID_SLAM_TEXT_TITLE, 0, 0, 150, 40, 0, 0x64, 0 },
  { BUTTON_CreateIndirect, "btnStart", ID_SLAM_BUTTON_START, 700, 0, 100, 120, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "btnStop", ID_SLAM_BUTTON_STOP, 700, 120, 100, 120, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "btnReset", ID_SLAM_BUTTON_RESET, 700, 240, 100, 120, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "btnExit", ID_SLAM_BUTTON_EXIT, 700, 360, 100, 120, 0, 0x0, 0 },
  { PROGBAR_CreateIndirect, "Progbar", ID_SLAM_PROGBAR_MAIN, 100, 450, 500, 20, 0, 0x0, 0 },
  { EDIT_CreateIndirect, "editXpos", ID_SLAM_EDIT_XPOS, 150, 415, 80, 20, 0, 0x64, 0 },
  { TEXT_CreateIndirect, "textXpos", ID_SLAM_TEXT_XPOS, 100, 415, 50, 20, 0, 0x64, 0 },
  { EDIT_CreateIndirect, "editYpos", ID_SLAM_EDIT_YPOS, 300, 415, 80, 20, 0, 0x64, 0 },
  { TEXT_CreateIndirect, "textYpos", ID_SLAM_TEXT_YPOS, 250, 415, 50, 20, 0, 0x64, 0 },
  { EDIT_CreateIndirect, "Edit", ID_SLAM_EDIT_RVALUE, 450, 415, 80, 20, 0, 0x64, 0 },
  { TEXT_CreateIndirect, "textRValue", ID_SLAM_TEXT_RVALUE, 400, 415, 50, 20, 0, 0x64, 0 },
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

static void SLAM_RobotFollowWallProc(void);

static void Button_Init(WM_HWIN hItem)
{
    BUTTON_SetFont(hItem, GUI_FONT_32_ASCII);
    BUTTON_SetSkinClassic(hItem);
    WIDGET_SetEffect(hItem, &WIDGET_Effect_Simple);
}

static void SLAM_ButtonStartClickedProc(void)
{
    SWRB_SLAM_ROBOT_PAINT_CB_REG(SLAM_RobotFollowWallProc);
}

static void SLAM_ButtonResetClickedProc(void)
{
    slamAngle = slamAngle;
    
    slamXPos = SWRB_SLAM_START_X_POS;
    slamYPos = SWRB_SLAM_START_Y_POS;
    slamAngle = SWRB_SLAM_START_ANGLE;
    SWRB_SLAM_ROBOT_PAINT_CB_DEREG();
}

static void SLAM_ButtonStopClickedProc(void)
{
    SWRB_SLAM_ROBOT_PAINT_CB_DEREG();
}

static void SLAM_ButtonExitClickedProc(void)
{
    if(gSwrbTestMode == SWRB_TEST_MODE_IDLE){

        gSwrbDialogSelectFlag = SWRB_DIALOG_SELECT_NONE;

        WM_HideWin(hWin_SWRB_SLAM);
        WM_ShowWin(hWin_SWRB_START);
    }
}

static void SWRB_SLAM_MAP_Init(void)
{
    /* Initialization of user widget */
}

static void SLAM_MapPaint(void)
{
    int i;
    
    GUI_SetColor(GUI_BLUE);
    GUI_DrawRect(SWRB_SLAM_MAP_X_START_POS, SWRB_SLAM_MAP_X_STOP_POS, SWRB_SLAM_MAP_Y_START_POS, SWRB_SLAM_MAP_Y_STOP_POS);
    GUI_SetColor(GUI_GRAY);

    /* Draw X axis Grids*/
    for(i=SWRB_SLAM_MAP_X_START_POS;i<=SWRB_SLAM_MAP_X_STOP_POS;i+=SWRB_SLAM_MAP_X_AXIS_GRID_SIZE){
        GUI_DrawLine(i, SWRB_SLAM_MAP_Y_START_POS, i, SWRB_SLAM_MAP_Y_STOP_POS);
    }

    /* Draw Y axis Grids*/
    for(i=SWRB_SLAM_MAP_Y_START_POS;i<=SWRB_SLAM_MAP_Y_STOP_POS;i+=SWRB_SLAM_MAP_Y_AXIS_GRID_SIZE){
        GUI_DrawLine(SWRB_SLAM_MAP_X_START_POS, i, SWRB_SLAM_MAP_X_STOP_POS, i);
    }
}

//static SWRB_SLAM_MAP_t SLAM_MapGridGet(u16 x, u16 y)
//{
//    int temp;
//    SWRB_SLAM_MAP_t map;
//    u16 gridCoordX, gridCoordY;
//    
//    temp = x;
//    while((temp--)%SWRB_SLAM_MAP_X_AXIS_GRID_SIZE);
//    map.GridStartXpos = temp;
//    
//    temp = x;
//    while((temp++)%SWRB_SLAM_MAP_X_AXIS_GRID_SIZE);
//    map.GridStopXpos = temp;
//    
//    temp = y;
//    while((temp--)%SWRB_SLAM_MAP_Y_AXIS_GRID_SIZE);
//    map.GridStartYpos = temp;
//    
//    temp = y;
//    while((temp++)%SWRB_SLAM_MAP_Y_AXIS_GRID_SIZE);
//    map.GridStopYpos = temp;
//    
//    gridCoordX = map.GridStartXpos/SWRB_SLAM_MAP_X_AXIS_GRID_SIZE;
//    gridCoordY = map.GridStartYpos/SWRB_SLAM_MAP_Y_AXIS_GRID_SIZE;
//    
//    gSLAMMap[gridCoordX][gridCoordY].GridStartXpos = map.GridStartXpos;
//    gSLAMMap[gridCoordX][gridCoordY].GridStartYpos = map.GridStartYpos;
//    gSLAMMap[gridCoordX][gridCoordY].GridStopXpos = map.GridStopXpos;
//    gSLAMMap[gridCoordX][gridCoordY].GridStopYpos = map.GridStopYpos;
//    gSLAMMap[gridCoordX][gridCoordY].flag = 1;
//    
//    return map;
//}

//static void SLAM_MapGridFlagSet(u16 gridCoordX, u16 gridCoordY, u8 flagState)
//{
//    gSLAMMap[gridCoordX][gridCoordY].flag = flagState;
//}

//static void SLAM_MapOneGridFill(u16 x, u16 y, GUI_COLOR color)
//{
//    SWRB_SLAM_MAP_t map;
//    GUI_COLOR lastColor;
//    
//    map = SLAM_MapGridGet(x,y);
//    
//    lastColor = GUI_GetColor();
//    GUI_SetColor(color);
//    GUI_FillRect(map.GridStartXpos, map.GridStartYpos, map.GridStopXpos, map.GridStopYpos);
//    GUI_SetColor(lastColor);
//}

//static void SLAM_MapGridFillStetDraw(GUI_COLOR color)
//{
//    int x,y;
//    u16 gridCoordX, gridCoordY;
//    GUI_COLOR lastColor;
//    
//    for(x=SWRB_SLAM_MAP_X_START_POS;x<=SWRB_SLAM_MAP_X_STOP_POS;x+=SWRB_SLAM_MAP_X_AXIS_GRID_SIZE){
//        gridCoordX = x/SWRB_SLAM_MAP_X_AXIS_GRID_SIZE;
//        for(y=SWRB_SLAM_MAP_Y_START_POS;y<=SWRB_SLAM_MAP_Y_STOP_POS;y+=SWRB_SLAM_MAP_Y_AXIS_GRID_SIZE){
//            gridCoordY = y/SWRB_SLAM_MAP_Y_AXIS_GRID_SIZE;
//            
//            if(gSLAMMap[gridCoordX][gridCoordY].flag){
//                lastColor = GUI_GetColor();
//                GUI_SetColor(color);
//                GUI_FillRect(gSLAMMap[gridCoordX][gridCoordY].GridStartXpos,\
//                             gSLAMMap[gridCoordX][gridCoordY].GridStartYpos,\
//                             gSLAMMap[gridCoordX][gridCoordY].GridStopXpos,\
//                             gSLAMMap[gridCoordX][gridCoordY].GridStopYpos);
//                GUI_SetColor(lastColor);
//            }
//        }
//    }
//}

//static void SLAM_MapGridPaint(void)
//{
//    SLAM_MapOneGridFill(slamXPos, slamYPos, GUI_GREEN);
//}

static void SLAM_RobotFollowWallProc(void)
{
    if(gRobotPosEdgeFlag == SLAM_ROBOT_POS_EDGE_VERTICAL){
        if(SWRB_SLAM_ROBOT_EAST_BOUND <= slamXPos){
            gRobotPosFlag = SLAM_ROBOT_POS_EAST;
            mymemcpy(pPolygonRobot, pPolygonRobotArray[SLAM_ROBOT_POS_SOUTH], sizeof(pPolygonRobot));
        }else if(SWRB_SLAM_ROBOT_WEST_BOUND >= slamXPos){
            gRobotPosFlag = SLAM_ROBOT_POS_WEST;
            mymemcpy(pPolygonRobot, pPolygonRobotArray[SLAM_ROBOT_POS_NORTH], sizeof(pPolygonRobot));
        }
    }
    
    if(gRobotPosEdgeFlag == SLAM_ROBOT_POS_EDGE_HORIZON){
        if(SWRB_SLAM_ROBOT_SOUTH_BOUND <= slamYPos){
            gRobotPosFlag = SLAM_ROBOT_POS_SOUTH;
            mymemcpy(pPolygonRobot, pPolygonRobotArray[SLAM_ROBOT_POS_WEST], sizeof(pPolygonRobot));
        }else if(SWRB_SLAM_ROBOT_NORTH_BOUND >= slamYPos){
            gRobotPosFlag = SLAM_ROBOT_POS_NORTH;
            mymemcpy(pPolygonRobot, pPolygonRobotArray[SLAM_ROBOT_POS_EAST], sizeof(pPolygonRobot));
        }
    }

    switch(gRobotPosFlag){
        case SLAM_ROBOT_POS_MIDDLE:
            slamYPos+=SWRB_SLAM_ROBOT_MOVE_PIXEL_SPEED;
            if(SWRB_SLAM_ROBOT_SOUTH_BOUND <= slamYPos || SWRB_SLAM_ROBOT_NORTH_BOUND >= slamYPos){
                gRobotPosEdgeFlag = SLAM_ROBOT_POS_EDGE_HORIZON;
            }
            mymemcpy(pPolygonRobot, pPolygonRobotArray[SLAM_ROBOT_POS_SOUTH], sizeof(pPolygonRobot));
            break;
        case SLAM_ROBOT_POS_NORTH:
            slamXPos+=SWRB_SLAM_ROBOT_MOVE_PIXEL_SPEED;
            if(SWRB_SLAM_ROBOT_EAST_BOUND <= slamXPos || SWRB_SLAM_ROBOT_WEST_BOUND >= slamXPos){
                gRobotPosEdgeFlag = SLAM_ROBOT_POS_EDGE_VERTICAL;
            }
            break;
        case SLAM_ROBOT_POS_EAST:
            slamYPos+=SWRB_SLAM_ROBOT_MOVE_PIXEL_SPEED;
            if(SWRB_SLAM_ROBOT_SOUTH_BOUND <= slamYPos || SWRB_SLAM_ROBOT_NORTH_BOUND >= slamYPos){
                gRobotPosEdgeFlag = SLAM_ROBOT_POS_EDGE_HORIZON;
            }
            break;
        case SLAM_ROBOT_POS_SOUTH:
            slamXPos-=SWRB_SLAM_ROBOT_MOVE_PIXEL_SPEED;
            if(SWRB_SLAM_ROBOT_EAST_BOUND <= slamXPos || SWRB_SLAM_ROBOT_WEST_BOUND >= slamXPos){
                gRobotPosEdgeFlag = SLAM_ROBOT_POS_EDGE_VERTICAL;
            }
            break;
        case SLAM_ROBOT_POS_WEST:
            slamYPos-=SWRB_SLAM_ROBOT_MOVE_PIXEL_SPEED;
            if(SWRB_SLAM_ROBOT_SOUTH_BOUND <= slamYPos || SWRB_SLAM_ROBOT_NORTH_BOUND >= slamYPos){
                gRobotPosEdgeFlag = SLAM_ROBOT_POS_EDGE_HORIZON;
            }
            break;
    }
}

static void SLAM_RobotPaint(int *x, int *y)
{
    if(SLAMRobotPaintCb != NULL){
        SLAMRobotPaintCb();
    }

    GUI_SetColor(GUI_RED);
    GUI_FillPolygon(pPolygonRobot, GUI_COUNTOF(pPolygonRobot), *x, *y);
}

//static void SLAM_TracePaint(void)
//{
//    if(gTraceNum < 1024){
//        gPolygonTrace[gTraceNum].x = slamXPos;
//        gPolygonTrace[gTraceNum].y = slamYPos;
//        gTraceNum++;
//        GUI_SetColor(GUI_BLUE);
//        GUI_DrawPolyLine(gPolygonTrace, gTraceNum*2, SWRB_SLAM_START_X_POS, SWRB_SLAM_START_Y_POS);
//    }
//}

static void SLAM_CoordDisp(void)
{
    WM_HWIN hItem;
    
    hItem = WM_GetDialogItem(hWin_SWRB_SLAM, ID_SLAM_EDIT_XPOS);
    EDIT_SetValue(hItem, slamXPos);
    
    hItem = WM_GetDialogItem(hWin_SWRB_SLAM, ID_SLAM_EDIT_YPOS);
    EDIT_SetValue(hItem, slamYPos);
}

static void SLAM_WMPaint(void)
{
    SLAM_MapPaint();
//    SLAM_MapGridPaint();
    SLAM_RobotPaint(&slamXPos, &slamYPos);
//    SLAM_TracePaint();
    SLAM_CoordDisp();
}

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg) {
  WM_HWIN hItem;
  int     NCode;
  int     Id;

  switch (pMsg->MsgId) {
  case WM_INIT_DIALOG:
    //
    // Initialization of 'Text'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_SLAM_TEXT_TITLE);
    TEXT_SetFont(hItem, GUI_FONT_24_ASCII);
    TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    TEXT_SetText(hItem, "SLAM Monitor");
    //
    // Initialization of 'btnStart'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_SLAM_BUTTON_START);
    Button_Init(hItem);
    BUTTON_SetText(hItem, "Start");
    //
    // Initialization of 'btnReset'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_SLAM_BUTTON_RESET);
    Button_Init(hItem);
    BUTTON_SetText(hItem, "Reset");
    //
    // Initialization of 'btnStop'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_SLAM_BUTTON_STOP);
    Button_Init(hItem);
    BUTTON_SetText(hItem, "Stop");
    //
    // Initialization of 'btnExit'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_SLAM_BUTTON_EXIT);
    Button_Init(hItem);
    BUTTON_SetText(hItem, "Exit");
    //
    // Initialization of 'editXpos'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_SLAM_EDIT_XPOS);
    EDIT_SetDecMode(hItem, 0, 0, 65535, 0, GUI_EDIT_SUPPRESS_LEADING_ZEROES);
    EDIT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    //
    // Initialization of 'textXpos'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_SLAM_TEXT_XPOS);
    TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    TEXT_SetText(hItem, "Xpos");
    //
    // Initialization of 'editYpos'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_SLAM_EDIT_YPOS);
    EDIT_SetDecMode(hItem, 0, 0, 65535, 0, GUI_EDIT_SUPPRESS_LEADING_ZEROES);
    EDIT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    //
    // Initialization of 'textYpos'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_SLAM_TEXT_YPOS);
    TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    TEXT_SetText(hItem, "Ypos");
    //
    // Initialization of 'editRvalue'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_SLAM_EDIT_RVALUE);
    EDIT_SetDecMode(hItem, 0, 0, 65535, 0, GUI_EDIT_SUPPRESS_LEADING_ZEROES);
    EDIT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    //
    // Initialization of 'textRValue'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_SLAM_TEXT_RVALUE);
    TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    TEXT_SetText(hItem, "RValue");

    SWRB_SLAM_ROBOT_PAINT_CB_DEREG();
    /* Hide Window when created */
    WM_HideWin(pMsg->hWin);

    break;
  case WM_PAINT:
    if(SLAMWMPaintCb != NULL)
        SLAMWMPaintCb();
    return;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case ID_SLAM_BUTTON_START: // Notifications sent by 'btnStart'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        break;
      case WM_NOTIFICATION_RELEASED:
        SLAM_ButtonStartClickedProc();
        break;
      }
      break;
    case ID_SLAM_BUTTON_RESET: // Notifications sent by 'btnReset'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        break;
      case WM_NOTIFICATION_RELEASED:
        SLAM_ButtonResetClickedProc();
        break;
      }
      break;
    case ID_SLAM_BUTTON_STOP: // Notifications sent by 'btnStop'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        break;
      case WM_NOTIFICATION_RELEASED:
        SLAM_ButtonStopClickedProc();
        break;
      }
      break;
    case ID_SLAM_BUTTON_EXIT: // Notifications sent by 'btnExit'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        break;
      case WM_NOTIFICATION_RELEASED:
        SLAM_ButtonExitClickedProc();
        break;
      }
      break;

    }
    break;

  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public data
*
**********************************************************************
*/

WM_HWIN hWin_SWRB_SLAM;

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateSLAMDLG
*/
WM_HWIN CreateEJE_SWRB_TEST_SLAMDLG(void)
{
    WM_HWIN hWin;

    SWRB_SLAM_MAP_Init();
    SWRB_SLAM_WM_PAINT_CB_REG(SLAM_WMPaint);
    SWRB_SLAM_ROBOT_PAINT_CB_REG(SLAM_RobotFollowWallProc);
    hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
    return hWin;
}

/*************************** End of file ****************************/
