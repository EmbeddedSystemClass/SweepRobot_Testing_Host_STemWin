/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.28                          *
*        Compiled Jan 30 2015, 16:41:06                              *
*        (c) 2015 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

#include "EJE_SWRB_TEST_DLG_Conf.h"
#include "sweeprobot_testing.h"

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/
static u8 gOnOffSwitchCnt = 0;
static u8 gModeSwitchCnt = 0;

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { WINDOW_CreateIndirect, "winCtrl", ID_CONTROL_WINDOW_MAIN, 0, 0, 800, 480, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "btnStart", ID_CONTROL_BUTTON_START, 700, 0, 100, 120, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "btnStop", ID_CONTROL_BUTTON_STOP, 700, 120, 100, 120, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "btnSet", ID_CONTROL_BUTTON_SET, 700, 240, 100, 120, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "btnExit", ID_CONTROL_BUTTON_EXIT, 700, 360, 100, 120, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "btnPlan", ID_CONTROL_BUTTON_PLAN, 60, 25, 140, 80, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "btnCharge", ID_CONTROL_BUTTON_CHARGE, 500, 25, 140, 80, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "btnON", ID_CONTROL_BUTTON_ONOFF, 300, 200, 100, 80, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "btnUp", ID_CONTROL_BUTTON_UP, 300, 50, 100, 80, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "btnLeft", ID_CONTROL_BUTTON_LEFT, 140, 200, 100, 80, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "btnDown", ID_CONTROL_BUTTON_DOWN, 300, 350, 100, 80, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "btnRight", ID_CONTROL_BUTTON_RIGHT, 450, 200, 100, 80, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "btnMode", ID_CONTROL_BUTTON_MODE, 60, 380, 140, 80, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "btnMode2", ID_CONTROL_BUTTON_MODE2, 60, 300, 140, 80, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "btnSpot", ID_CONTROL_BUTTON_SPOT, 500, 380, 140, 80, 0, 0x0, 0 },
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

static void Button_EXITProc(void)
{
    gSwrbDialogSelectFlag = SWRB_DIALOG_SELECT_NONE;
    
//    STD_UART_RX_ENABLE();
    STD_UART_DISABLE();
    
    WM_HideWin(hWin_SWRB_CONTROL);
    WM_ShowWin(hWin_SWRB_START);
}

//#define REMOTE_CMD_CHARGE                   0xAC
//#define REMOTE_CMD_UP                       0xBE
//#define REMOTE_CMD_LEFT                     0xBA
//#define REMOTE_CMD_DOWN                     0xBC
//#define REMOTE_CMD_RIGHT                    0xB8
//#define REMOTE_CMD_RUN_STOP                 0x8A
//#define REMOTE_CMD_MODE_AUTO                0xAF
//#define REMOTE_CMD_MODE_1                   0xB4
//#define REMOTE_CMD_MODE_2                   0xB3
//#define REMOTE_CMD_MODE_3                   0xB2
//#define REMOTE_CMD_MODE_4                   0xB0
//#define REMOTE_CMD_SPOT                     0xB5

static void Button_PLANProc(void)
{
//    printf("CTRL->MSG=
}

static void Button_CHARGEProc(void)
{
    printf("CTRL->MSG=172\r\n");    //0xAC,REMOTE_CMD_CHARGE
}

static void Button_UPProc(void)
{
    printf("CTRL->MSG=190\r\n");    //0xBE,REMOTE_CMD_UP
}

static void Button_LEFTProc(void)
{
    printf("CTRL->MSG=186\r\n");    //0xBA,REMOTE_CMD_LEFT
}

static void Button_RIGHTProc(void)
{
    printf("CTRL->MSG=184\r\n");    //0xB8,REMOTE_CMD_RIGHT
}

static void Button_DOWNProc(void)
{
    printf("CTRL->MSG=188\r\n");    //0xBC,REMOTE_CMD_DOWN
}

static void Button_ONOFFProc(void)
{
    if(gOnOffSwitchCnt){
        Button_Set_Text(hWin_SWRB_CONTROL, ID_CONTROL_BUTTON_ONOFF, "ON");
        gOnOffSwitchCnt = 0;
    }else{
        Button_Set_Text(hWin_SWRB_CONTROL, ID_CONTROL_BUTTON_ONOFF, "OFF");
        gOnOffSwitchCnt = 1;
    }
    printf("CTRL->MSG=138\r\n");    //0x8A,REMOTE_CMD_RUN_STOP
}

static void Button_MODEProc(void)
{
    
    switch(gModeSwitchCnt){
        case 0:
            printf("CTRL->MSG=175\r\n");    //0xAF,REMOTE_CMD_MODE_AUTO
            Button_Set_Text(hWin_SWRB_CONTROL, ID_CONTROL_BUTTON_MODE, "MODE AUTO");
            gModeSwitchCnt++;
            break;
        case 1:
            printf("CTRL->MSG=180\r\n");    //0xB4,REMOTE_CMD_MODE_1
            Button_Set_Text(hWin_SWRB_CONTROL, ID_CONTROL_BUTTON_MODE, "MODE 1");
            gModeSwitchCnt++;
            break;
        case 2:
            printf("CTRL->MSG=179\r\n");    //0xB3,REMOTE_CMD_MODE_2
            Button_Set_Text(hWin_SWRB_CONTROL, ID_CONTROL_BUTTON_MODE, "MODE 2");
            gModeSwitchCnt++;
            break;
        case 3:
            printf("CTRL->MSG=178\r\n");    //0xB2,REMOTE_CMD_MODE_3
            Button_Set_Text(hWin_SWRB_CONTROL, ID_CONTROL_BUTTON_MODE, "MODE 3");
            gModeSwitchCnt++;
            break;
        case 4:
            printf("CTRL->MSG=176\r\n");    //0xB0,REMOTE_CMD_MODE_4
            Button_Set_Text(hWin_SWRB_CONTROL, ID_CONTROL_BUTTON_MODE, "MODE 4");
            gModeSwitchCnt=0;
            break;
        default:break;
    }
}

static void Button_MODE2Proc(void)
{
    printf("CTRL->MSG=179\r\n");
}

static void Button_SPOTProc(void)
{
    printf("CTRL->MSG=181\r\n");    //0xB5,REMOTE_CMD_SPOT
}

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg) {
  WM_HWIN hItem;
  int     NCode;
  int     Id;
  // USER START (Optionally insert additional variables)
  // USER END

  switch (pMsg->MsgId) {
  case WM_INIT_DIALOG:
    //
    // Initialization of 'btnStart'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_CONTROL_BUTTON_START);
    BUTTON_SetFont(hItem, GUI_FONT_24_ASCII);
    BUTTON_SetText(hItem, "Start");
    //
    // Initialization of 'btnStop'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_CONTROL_BUTTON_STOP);
    BUTTON_SetFont(hItem, GUI_FONT_24_ASCII);
    BUTTON_SetText(hItem, "Stop");
    //
    // Initialization of 'btnSet'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_CONTROL_BUTTON_SET);
    BUTTON_SetFont(hItem, GUI_FONT_24_ASCII);
    BUTTON_SetText(hItem, "Set");
    //
    // Initialization of 'btnExit'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_CONTROL_BUTTON_EXIT);
    BUTTON_SetFont(hItem, GUI_FONT_24_ASCII);
    BUTTON_SetText(hItem, "Exit");
    //
    // Initialization of 'btnPlan'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_CONTROL_BUTTON_PLAN);
    BUTTON_SetFont(hItem, GUI_FONT_24_ASCII);
    BUTTON_SetText(hItem, "PLAN");
    //
    // Initialization of 'btnCharge'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_CONTROL_BUTTON_CHARGE);
    BUTTON_SetFont(hItem, GUI_FONT_24_ASCII);
    BUTTON_SetText(hItem, "CHARGE");
    //
    // Initialization of 'btnON'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_CONTROL_BUTTON_ONOFF);
    BUTTON_SetFont(hItem, GUI_FONT_24_ASCII);
    BUTTON_SetText(hItem, "ON");
    //
    // Initialization of 'btnUp'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_CONTROL_BUTTON_UP);
    BUTTON_SetFont(hItem, GUI_FONT_24_ASCII);
    BUTTON_SetText(hItem, "UP");
    //
    // Initialization of 'btnLeft'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_CONTROL_BUTTON_LEFT);
    BUTTON_SetFont(hItem, GUI_FONT_24_ASCII);
    BUTTON_SetText(hItem, "LEFT");
    //
    // Initialization of 'btnDown'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_CONTROL_BUTTON_DOWN);
    BUTTON_SetFont(hItem, GUI_FONT_24_ASCII);
    BUTTON_SetText(hItem, "DOWN");
    //
    // Initialization of 'btnRight'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_CONTROL_BUTTON_RIGHT);
    BUTTON_SetFont(hItem, GUI_FONT_24_ASCII);
    BUTTON_SetText(hItem, "RIGHT");
    //
    // Initialization of 'btnMode'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_CONTROL_BUTTON_MODE);
    BUTTON_SetFont(hItem, GUI_FONT_16_ASCII);
    BUTTON_SetText(hItem, "MODE AUTO");
    
    hItem = WM_GetDialogItem(pMsg->hWin, ID_CONTROL_BUTTON_MODE2);
    BUTTON_SetFont(hItem, GUI_FONT_20_ASCII);
    BUTTON_SetText(hItem, "MODE2");
    //
    // Initialization of 'btnSpot'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_CONTROL_BUTTON_SPOT);
    BUTTON_SetFont(hItem, GUI_FONT_24_ASCII);
    BUTTON_SetText(hItem, "SPOT");
    
    WM_HideWin(pMsg->hWin);
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case ID_CONTROL_BUTTON_START: // Notifications sent by 'btnStart'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_CONTROL_BUTTON_STOP: // Notifications sent by 'btnStop'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_CONTROL_BUTTON_SET: // Notifications sent by 'btnSet'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_CONTROL_BUTTON_EXIT: // Notifications sent by 'btnExit'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
          Button_EXITProc();
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_CONTROL_BUTTON_PLAN: // Notifications sent by 'btnPlan'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_CONTROL_BUTTON_CHARGE: // Notifications sent by 'btnCharge'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        Button_CHARGEProc();
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_CONTROL_BUTTON_ONOFF: // Notifications sent by 'btnON'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        Button_ONOFFProc();
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_CONTROL_BUTTON_UP: // Notifications sent by 'btnUp'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
          Button_UPProc();
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
          
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_CONTROL_BUTTON_LEFT: // Notifications sent by 'btnLeft'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
          Button_LEFTProc();
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
          
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_CONTROL_BUTTON_DOWN: // Notifications sent by 'btnDown'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
          Button_DOWNProc();
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
          
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_CONTROL_BUTTON_RIGHT: // Notifications sent by 'btnRight'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
          Button_RIGHTProc();
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
          
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_CONTROL_BUTTON_MODE: // Notifications sent by 'btnMode'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        break;
      case WM_NOTIFICATION_RELEASED:
        Button_MODEProc();
        break;
      }
      break;
    case ID_CONTROL_BUTTON_MODE2: // Notifications sent by 'btnMode2'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        break;
      case WM_NOTIFICATION_RELEASED:
        Button_MODE2Proc();
        break;
      }
      break;
    case ID_CONTROL_BUTTON_SPOT: // Notifications sent by 'btnSpot'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
          Button_SPOTProc();
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    // USER START (Optionally insert additional code for further Ids)
    // USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}
/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
WM_HWIN hWin_SWRB_CONTROL;

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreatewinCtrl
*/
WM_HWIN CreatewinCtrlDLG(void) {
  WM_HWIN hWin;

  hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
  return hWin;
}

/*************************** End of file ****************************/
